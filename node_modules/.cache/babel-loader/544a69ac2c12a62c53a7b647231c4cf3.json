{"ast":null,"code":"(function (factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === \"object\") {\n    // Node/CommonJS\n    module.exports = factory();\n  } else {\n    // Browser globals\n    window.wNumb = factory();\n  }\n})(function () {\n  \"use strict\";\n\n  var FormatOptions = [\"decimals\", \"thousand\", \"mark\", \"prefix\", \"suffix\", \"encoder\", \"decoder\", \"negativeBefore\", \"negative\", \"edit\", \"undo\"];\n\n  // General\n\n  // Reverse a string\n  function strReverse(a) {\n    return a.split(\"\").reverse().join(\"\");\n  }\n\n  // Check if a string starts with a specified prefix.\n  function strStartsWith(input, match) {\n    return input.substring(0, match.length) === match;\n  }\n\n  // Check is a string ends in a specified suffix.\n  function strEndsWith(input, match) {\n    return input.slice(-1 * match.length) === match;\n  }\n\n  // Throw an error if formatting options are incompatible.\n  function throwEqualError(F, a, b) {\n    if ((F[a] || F[b]) && F[a] === F[b]) {\n      throw new Error(a);\n    }\n  }\n\n  // Check if a number is finite and not NaN\n  function isValidNumber(input) {\n    return typeof input === \"number\" && isFinite(input);\n  }\n\n  // Provide rounding-accurate toFixed method.\n  // Borrowed: http://stackoverflow.com/a/21323330/775265\n  function toFixed(value, exp) {\n    value = value.toString().split(\"e\");\n    value = Math.round(+(value[0] + \"e\" + (value[1] ? +value[1] + exp : exp)));\n    value = value.toString().split(\"e\");\n    return (+(value[0] + \"e\" + (value[1] ? +value[1] - exp : -exp))).toFixed(exp);\n  }\n\n  // Formatting\n\n  // Accept a number as input, output formatted string.\n  function formatTo(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {\n    var originalInput = input,\n      inputIsNegative,\n      inputPieces,\n      inputBase,\n      inputDecimals = \"\",\n      output = \"\";\n\n    // Apply user encoder to the input.\n    // Expected outcome: number.\n    if (encoder) {\n      input = encoder(input);\n    }\n\n    // Stop if no valid number was provided, the number is infinite or NaN.\n    if (!isValidNumber(input)) {\n      return false;\n    }\n\n    // Rounding away decimals might cause a value of -0\n    // when using very small ranges. Remove those cases.\n    if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {\n      input = 0;\n    }\n\n    // Formatting is done on absolute numbers,\n    // decorated by an optional negative symbol.\n    if (input < 0) {\n      inputIsNegative = true;\n      input = Math.abs(input);\n    }\n\n    // Reduce the number of decimals to the specified option.\n    if (decimals !== false) {\n      input = toFixed(input, decimals);\n    }\n\n    // Transform the number into a string, so it can be split.\n    input = input.toString();\n\n    // Break the number on the decimal separator.\n    if (input.indexOf(\".\") !== -1) {\n      inputPieces = input.split(\".\");\n      inputBase = inputPieces[0];\n      if (mark) {\n        inputDecimals = mark + inputPieces[1];\n      }\n    } else {\n      // If it isn't split, the entire number will do.\n      inputBase = input;\n    }\n\n    // Group numbers in sets of three.\n    if (thousand) {\n      inputBase = strReverse(inputBase).match(/.{1,3}/g);\n      inputBase = strReverse(inputBase.join(strReverse(thousand)));\n    }\n\n    // If the number is negative, prefix with negation symbol.\n    if (inputIsNegative && negativeBefore) {\n      output += negativeBefore;\n    }\n\n    // Prefix the number\n    if (prefix) {\n      output += prefix;\n    }\n\n    // Normal negative option comes after the prefix. Defaults to '-'.\n    if (inputIsNegative && negative) {\n      output += negative;\n    }\n\n    // Append the actual number.\n    output += inputBase;\n    output += inputDecimals;\n\n    // Apply the suffix.\n    if (suffix) {\n      output += suffix;\n    }\n\n    // Run the output through a user-specified post-formatter.\n    if (edit) {\n      output = edit(output, originalInput);\n    }\n\n    // All done.\n    return output;\n  }\n\n  // Accept a sting as input, output decoded number.\n  function formatFrom(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {\n    var originalInput = input,\n      inputIsNegative,\n      output = \"\";\n\n    // User defined pre-decoder. Result must be a non empty string.\n    if (undo) {\n      input = undo(input);\n    }\n\n    // Test the input. Can't be empty.\n    if (!input || typeof input !== \"string\") {\n      return false;\n    }\n\n    // If the string starts with the negativeBefore value: remove it.\n    // Remember is was there, the number is negative.\n    if (negativeBefore && strStartsWith(input, negativeBefore)) {\n      input = input.replace(negativeBefore, \"\");\n      inputIsNegative = true;\n    }\n\n    // Repeat the same procedure for the prefix.\n    if (prefix && strStartsWith(input, prefix)) {\n      input = input.replace(prefix, \"\");\n    }\n\n    // And again for negative.\n    if (negative && strStartsWith(input, negative)) {\n      input = input.replace(negative, \"\");\n      inputIsNegative = true;\n    }\n\n    // Remove the suffix.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice\n    if (suffix && strEndsWith(input, suffix)) {\n      input = input.slice(0, -1 * suffix.length);\n    }\n\n    // Remove the thousand grouping.\n    if (thousand) {\n      input = input.split(thousand).join(\"\");\n    }\n\n    // Set the decimal separator back to period.\n    if (mark) {\n      input = input.replace(mark, \".\");\n    }\n\n    // Prepend the negative symbol.\n    if (inputIsNegative) {\n      output += \"-\";\n    }\n\n    // Add the number\n    output += input;\n\n    // Trim all non-numeric characters (allow '.' and '-');\n    output = output.replace(/[^0-9\\.\\-.]/g, \"\");\n\n    // The value contains no parse-able number.\n    if (output === \"\") {\n      return false;\n    }\n\n    // Covert to number.\n    output = Number(output);\n\n    // Run the user-specified post-decoder.\n    if (decoder) {\n      output = decoder(output);\n    }\n\n    // Check is the output is valid, otherwise: return false.\n    if (!isValidNumber(output)) {\n      return false;\n    }\n    return output;\n  }\n\n  // Framework\n\n  // Validate formatting options\n  function validate(inputOptions) {\n    var i,\n      optionName,\n      optionValue,\n      filteredOptions = {};\n    if (inputOptions[\"suffix\"] === undefined) {\n      inputOptions[\"suffix\"] = inputOptions[\"postfix\"];\n    }\n    for (i = 0; i < FormatOptions.length; i += 1) {\n      optionName = FormatOptions[i];\n      optionValue = inputOptions[optionName];\n      if (optionValue === undefined) {\n        // Only default if negativeBefore isn't set.\n        if (optionName === \"negative\" && !filteredOptions.negativeBefore) {\n          filteredOptions[optionName] = \"-\";\n          // Don't set a default for mark when 'thousand' is set.\n        } else if (optionName === \"mark\" && filteredOptions.thousand !== \".\") {\n          filteredOptions[optionName] = \".\";\n        } else {\n          filteredOptions[optionName] = false;\n        }\n\n        // Floating points in JS are stable up to 7 decimals.\n      } else if (optionName === \"decimals\") {\n        if (optionValue >= 0 && optionValue < 8) {\n          filteredOptions[optionName] = optionValue;\n        } else {\n          throw new Error(optionName);\n        }\n\n        // These options, when provided, must be functions.\n      } else if (optionName === \"encoder\" || optionName === \"decoder\" || optionName === \"edit\" || optionName === \"undo\") {\n        if (typeof optionValue === \"function\") {\n          filteredOptions[optionName] = optionValue;\n        } else {\n          throw new Error(optionName);\n        }\n\n        // Other options are strings.\n      } else {\n        if (typeof optionValue === \"string\") {\n          filteredOptions[optionName] = optionValue;\n        } else {\n          throw new Error(optionName);\n        }\n      }\n    }\n\n    // Some values can't be extracted from a\n    // string if certain combinations are present.\n    throwEqualError(filteredOptions, \"mark\", \"thousand\");\n    throwEqualError(filteredOptions, \"prefix\", \"negative\");\n    throwEqualError(filteredOptions, \"prefix\", \"negativeBefore\");\n    return filteredOptions;\n  }\n\n  // Pass all options as function arguments\n  function passAll(options, method, input) {\n    var i,\n      args = [];\n\n    // Add all options in order of FormatOptions\n    for (i = 0; i < FormatOptions.length; i += 1) {\n      args.push(options[FormatOptions[i]]);\n    }\n\n    // Append the input, then call the method, presenting all\n    // options as arguments.\n    args.push(input);\n    return method.apply(\"\", args);\n  }\n  function wNumb(options) {\n    if (!(this instanceof wNumb)) {\n      return new wNumb(options);\n    }\n    if (typeof options !== \"object\") {\n      return;\n    }\n    options = validate(options);\n\n    // Call 'formatTo' with proper arguments.\n    this.to = function (input) {\n      return passAll(options, formatTo, input);\n    };\n\n    // Call 'formatFrom' with proper arguments.\n    this.from = function (input) {\n      return passAll(options, formatFrom, input);\n    };\n  }\n  return wNumb;\n});","map":{"version":3,"names":["factory","define","amd","exports","module","window","wNumb","FormatOptions","strReverse","a","split","reverse","join","strStartsWith","input","match","substring","length","strEndsWith","slice","throwEqualError","F","b","Error","isValidNumber","isFinite","toFixed","value","exp","toString","Math","round","formatTo","decimals","thousand","mark","prefix","suffix","encoder","decoder","negativeBefore","negative","edit","undo","originalInput","inputIsNegative","inputPieces","inputBase","inputDecimals","output","parseFloat","abs","indexOf","formatFrom","replace","Number","validate","inputOptions","i","optionName","optionValue","filteredOptions","undefined","passAll","options","method","args","push","apply","to","from"],"sources":["/Users/admin/full-version/node_modules/wnumb/wNumb.js"],"sourcesContent":["(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define([], factory);\r\n  } else if (typeof exports === \"object\") {\r\n    // Node/CommonJS\r\n    module.exports = factory();\r\n  } else {\r\n    // Browser globals\r\n    window.wNumb = factory();\r\n  }\r\n})(function() {\r\n  \"use strict\";\r\n\r\n  var FormatOptions = [\r\n    \"decimals\",\r\n    \"thousand\",\r\n    \"mark\",\r\n    \"prefix\",\r\n    \"suffix\",\r\n    \"encoder\",\r\n    \"decoder\",\r\n    \"negativeBefore\",\r\n    \"negative\",\r\n    \"edit\",\r\n    \"undo\"\r\n  ];\r\n\r\n  // General\r\n\r\n  // Reverse a string\r\n  function strReverse(a) {\r\n    return a\r\n      .split(\"\")\r\n      .reverse()\r\n      .join(\"\");\r\n  }\r\n\r\n  // Check if a string starts with a specified prefix.\r\n  function strStartsWith(input, match) {\r\n    return input.substring(0, match.length) === match;\r\n  }\r\n\r\n  // Check is a string ends in a specified suffix.\r\n  function strEndsWith(input, match) {\r\n    return input.slice(-1 * match.length) === match;\r\n  }\r\n\r\n  // Throw an error if formatting options are incompatible.\r\n  function throwEqualError(F, a, b) {\r\n    if ((F[a] || F[b]) && F[a] === F[b]) {\r\n      throw new Error(a);\r\n    }\r\n  }\r\n\r\n  // Check if a number is finite and not NaN\r\n  function isValidNumber(input) {\r\n    return typeof input === \"number\" && isFinite(input);\r\n  }\r\n\r\n  // Provide rounding-accurate toFixed method.\r\n  // Borrowed: http://stackoverflow.com/a/21323330/775265\r\n  function toFixed(value, exp) {\r\n    value = value.toString().split(\"e\");\r\n    value = Math.round(+(value[0] + \"e\" + (value[1] ? +value[1] + exp : exp)));\r\n    value = value.toString().split(\"e\");\r\n    return (+(value[0] + \"e\" + (value[1] ? +value[1] - exp : -exp))).toFixed(exp);\r\n  }\r\n\r\n  // Formatting\r\n\r\n  // Accept a number as input, output formatted string.\r\n  function formatTo(\r\n    decimals,\r\n    thousand,\r\n    mark,\r\n    prefix,\r\n    suffix,\r\n    encoder,\r\n    decoder,\r\n    negativeBefore,\r\n    negative,\r\n    edit,\r\n    undo,\r\n    input\r\n  ) {\r\n    var originalInput = input,\r\n      inputIsNegative,\r\n      inputPieces,\r\n      inputBase,\r\n      inputDecimals = \"\",\r\n      output = \"\";\r\n\r\n    // Apply user encoder to the input.\r\n    // Expected outcome: number.\r\n    if (encoder) {\r\n      input = encoder(input);\r\n    }\r\n\r\n    // Stop if no valid number was provided, the number is infinite or NaN.\r\n    if (!isValidNumber(input)) {\r\n      return false;\r\n    }\r\n\r\n    // Rounding away decimals might cause a value of -0\r\n    // when using very small ranges. Remove those cases.\r\n    if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {\r\n      input = 0;\r\n    }\r\n\r\n    // Formatting is done on absolute numbers,\r\n    // decorated by an optional negative symbol.\r\n    if (input < 0) {\r\n      inputIsNegative = true;\r\n      input = Math.abs(input);\r\n    }\r\n\r\n    // Reduce the number of decimals to the specified option.\r\n    if (decimals !== false) {\r\n      input = toFixed(input, decimals);\r\n    }\r\n\r\n    // Transform the number into a string, so it can be split.\r\n    input = input.toString();\r\n\r\n    // Break the number on the decimal separator.\r\n    if (input.indexOf(\".\") !== -1) {\r\n      inputPieces = input.split(\".\");\r\n\r\n      inputBase = inputPieces[0];\r\n\r\n      if (mark) {\r\n        inputDecimals = mark + inputPieces[1];\r\n      }\r\n    } else {\r\n      // If it isn't split, the entire number will do.\r\n      inputBase = input;\r\n    }\r\n\r\n    // Group numbers in sets of three.\r\n    if (thousand) {\r\n      inputBase = strReverse(inputBase).match(/.{1,3}/g);\r\n      inputBase = strReverse(inputBase.join(strReverse(thousand)));\r\n    }\r\n\r\n    // If the number is negative, prefix with negation symbol.\r\n    if (inputIsNegative && negativeBefore) {\r\n      output += negativeBefore;\r\n    }\r\n\r\n    // Prefix the number\r\n    if (prefix) {\r\n      output += prefix;\r\n    }\r\n\r\n    // Normal negative option comes after the prefix. Defaults to '-'.\r\n    if (inputIsNegative && negative) {\r\n      output += negative;\r\n    }\r\n\r\n    // Append the actual number.\r\n    output += inputBase;\r\n    output += inputDecimals;\r\n\r\n    // Apply the suffix.\r\n    if (suffix) {\r\n      output += suffix;\r\n    }\r\n\r\n    // Run the output through a user-specified post-formatter.\r\n    if (edit) {\r\n      output = edit(output, originalInput);\r\n    }\r\n\r\n    // All done.\r\n    return output;\r\n  }\r\n\r\n  // Accept a sting as input, output decoded number.\r\n  function formatFrom(\r\n    decimals,\r\n    thousand,\r\n    mark,\r\n    prefix,\r\n    suffix,\r\n    encoder,\r\n    decoder,\r\n    negativeBefore,\r\n    negative,\r\n    edit,\r\n    undo,\r\n    input\r\n  ) {\r\n    var originalInput = input,\r\n      inputIsNegative,\r\n      output = \"\";\r\n\r\n    // User defined pre-decoder. Result must be a non empty string.\r\n    if (undo) {\r\n      input = undo(input);\r\n    }\r\n\r\n    // Test the input. Can't be empty.\r\n    if (!input || typeof input !== \"string\") {\r\n      return false;\r\n    }\r\n\r\n    // If the string starts with the negativeBefore value: remove it.\r\n    // Remember is was there, the number is negative.\r\n    if (negativeBefore && strStartsWith(input, negativeBefore)) {\r\n      input = input.replace(negativeBefore, \"\");\r\n      inputIsNegative = true;\r\n    }\r\n\r\n    // Repeat the same procedure for the prefix.\r\n    if (prefix && strStartsWith(input, prefix)) {\r\n      input = input.replace(prefix, \"\");\r\n    }\r\n\r\n    // And again for negative.\r\n    if (negative && strStartsWith(input, negative)) {\r\n      input = input.replace(negative, \"\");\r\n      inputIsNegative = true;\r\n    }\r\n\r\n    // Remove the suffix.\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice\r\n    if (suffix && strEndsWith(input, suffix)) {\r\n      input = input.slice(0, -1 * suffix.length);\r\n    }\r\n\r\n    // Remove the thousand grouping.\r\n    if (thousand) {\r\n      input = input.split(thousand).join(\"\");\r\n    }\r\n\r\n    // Set the decimal separator back to period.\r\n    if (mark) {\r\n      input = input.replace(mark, \".\");\r\n    }\r\n\r\n    // Prepend the negative symbol.\r\n    if (inputIsNegative) {\r\n      output += \"-\";\r\n    }\r\n\r\n    // Add the number\r\n    output += input;\r\n\r\n    // Trim all non-numeric characters (allow '.' and '-');\r\n    output = output.replace(/[^0-9\\.\\-.]/g, \"\");\r\n\r\n    // The value contains no parse-able number.\r\n    if (output === \"\") {\r\n      return false;\r\n    }\r\n\r\n    // Covert to number.\r\n    output = Number(output);\r\n\r\n    // Run the user-specified post-decoder.\r\n    if (decoder) {\r\n      output = decoder(output);\r\n    }\r\n\r\n    // Check is the output is valid, otherwise: return false.\r\n    if (!isValidNumber(output)) {\r\n      return false;\r\n    }\r\n\r\n    return output;\r\n  }\r\n\r\n  // Framework\r\n\r\n  // Validate formatting options\r\n  function validate(inputOptions) {\r\n    var i,\r\n      optionName,\r\n      optionValue,\r\n      filteredOptions = {};\r\n\r\n    if (inputOptions[\"suffix\"] === undefined) {\r\n      inputOptions[\"suffix\"] = inputOptions[\"postfix\"];\r\n    }\r\n\r\n    for (i = 0; i < FormatOptions.length; i += 1) {\r\n      optionName = FormatOptions[i];\r\n      optionValue = inputOptions[optionName];\r\n\r\n      if (optionValue === undefined) {\r\n        // Only default if negativeBefore isn't set.\r\n        if (optionName === \"negative\" && !filteredOptions.negativeBefore) {\r\n          filteredOptions[optionName] = \"-\";\r\n          // Don't set a default for mark when 'thousand' is set.\r\n        } else if (optionName === \"mark\" && filteredOptions.thousand !== \".\") {\r\n          filteredOptions[optionName] = \".\";\r\n        } else {\r\n          filteredOptions[optionName] = false;\r\n        }\r\n\r\n        // Floating points in JS are stable up to 7 decimals.\r\n      } else if (optionName === \"decimals\") {\r\n        if (optionValue >= 0 && optionValue < 8) {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n\r\n        // These options, when provided, must be functions.\r\n      } else if (\r\n        optionName === \"encoder\" ||\r\n        optionName === \"decoder\" ||\r\n        optionName === \"edit\" ||\r\n        optionName === \"undo\"\r\n      ) {\r\n        if (typeof optionValue === \"function\") {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n\r\n        // Other options are strings.\r\n      } else {\r\n        if (typeof optionValue === \"string\") {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Some values can't be extracted from a\r\n    // string if certain combinations are present.\r\n    throwEqualError(filteredOptions, \"mark\", \"thousand\");\r\n    throwEqualError(filteredOptions, \"prefix\", \"negative\");\r\n    throwEqualError(filteredOptions, \"prefix\", \"negativeBefore\");\r\n\r\n    return filteredOptions;\r\n  }\r\n\r\n  // Pass all options as function arguments\r\n  function passAll(options, method, input) {\r\n    var i,\r\n      args = [];\r\n\r\n    // Add all options in order of FormatOptions\r\n    for (i = 0; i < FormatOptions.length; i += 1) {\r\n      args.push(options[FormatOptions[i]]);\r\n    }\r\n\r\n    // Append the input, then call the method, presenting all\r\n    // options as arguments.\r\n    args.push(input);\r\n    return method.apply(\"\", args);\r\n  }\r\n\r\n  function wNumb(options) {\r\n    if (!(this instanceof wNumb)) {\r\n      return new wNumb(options);\r\n    }\r\n\r\n    if (typeof options !== \"object\") {\r\n      return;\r\n    }\r\n\r\n    options = validate(options);\r\n\r\n    // Call 'formatTo' with proper arguments.\r\n    this.to = function(input) {\r\n      return passAll(options, formatTo, input);\r\n    };\r\n\r\n    // Call 'formatFrom' with proper arguments.\r\n    this.from = function(input) {\r\n      return passAll(options, formatFrom, input);\r\n    };\r\n  }\r\n\r\n  return wNumb;\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}