{"ast":null,"code":"import { ITSELF as r, createInterpreter as n } from \"@ucast/core\";\nfunction t(r, n, t) {\n  for (var u = 0, e = r.length; u < e; u++) if (0 === t(r[u], n)) return !0;\n  return !1;\n}\nfunction u(r, n) {\n  return Array.isArray(r) && Number.isNaN(Number(n));\n}\nfunction e(r, n, t) {\n  if (!u(r, n)) return t(r, n);\n  for (var e = [], o = 0; o < r.length; o++) {\n    var i = t(r[o], n);\n    void 0 !== i && (e = e.concat(i));\n  }\n  return e;\n}\nfunction o(r) {\n  return function (n, t, u) {\n    var e = u.get(t, n.field);\n    return Array.isArray(e) ? e.some(function (t) {\n      return r(n, t, u);\n    }) : r(n, e, u);\n  };\n}\nfunction i() {\n  return (i = Object.assign || function (r) {\n    for (var n = 1; n < arguments.length; n++) {\n      var t = arguments[n];\n      for (var u in t) Object.prototype.hasOwnProperty.call(t, u) && (r[u] = t[u]);\n    }\n    return r;\n  }).apply(this, arguments);\n}\nvar f = function (r, n) {\n  return r[n];\n};\nfunction c(r, n, t) {\n  var u = n.lastIndexOf(\".\");\n  return -1 === u ? [r, n] : [t(r, n.slice(0, u)), n.slice(u + 1)];\n}\nfunction a(n, t, u) {\n  if (void 0 === u && (u = f), t === r) return n;\n  if (!n) throw new Error('Unable to get field \"' + t + '\" out of ' + String(n) + \".\");\n  return function (r, n, t) {\n    if (-1 === n.indexOf(\".\")) return e(r, n, t);\n    for (var u = n.split(\".\"), o = r, i = 0, f = u.length; i < f; i++) if (!(o = e(o, u[i], t)) || \"object\" != typeof o) return o;\n    return o;\n  }(n, t, u);\n}\nfunction v(r) {\n  return function (n, t) {\n    return a(n, t, r);\n  };\n}\nfunction y(r, n) {\n  return r === n ? 0 : r > n ? 1 : -1;\n}\nfunction l(r, t) {\n  return void 0 === t && (t = {}), n(r, i({\n    get: a,\n    compare: y\n  }, t));\n}\nvar b = function (r, n, t) {\n    var u = t.interpret;\n    return r.value.some(function (r) {\n      return u(r, n);\n    });\n  },\n  m = function (r, n, t) {\n    return !b(r, n, t);\n  },\n  d = function (r, n, t) {\n    var u = t.interpret;\n    return r.value.every(function (r) {\n      return u(r, n);\n    });\n  },\n  g = function (r, n, t) {\n    return !(0, t.interpret)(r.value[0], n);\n  },\n  p = function (r, n, u) {\n    var e = u.compare,\n      o = (0, u.get)(n, r.field);\n    return Array.isArray(o) && !Array.isArray(r.value) ? t(o, r.value, e) : 0 === e(o, r.value);\n  },\n  A = function (r, n, t) {\n    return !p(r, n, t);\n  },\n  s = o(function (r, n, t) {\n    var u = t.compare(n, r.value);\n    return 0 === u || -1 === u;\n  }),\n  h = o(function (r, n, t) {\n    return -1 === t.compare(n, r.value);\n  }),\n  j = o(function (r, n, t) {\n    return 1 === t.compare(n, r.value);\n  }),\n  w = o(function (r, n, t) {\n    var u = t.compare(n, r.value);\n    return 0 === u || 1 === u;\n  }),\n  _ = function (n, t, e) {\n    var o = e.get;\n    if (n.field === r) return void 0 !== t;\n    var i = c(t, n.field, o),\n      f = i[0],\n      a = i[1],\n      v = function (r) {\n        return !!r && r.hasOwnProperty(a) === n.value;\n      };\n    return u(f, a) ? f.some(v) : v(f);\n  },\n  x = o(function (r, n) {\n    return \"number\" == typeof n && n % r.value[0] === r.value[1];\n  }),\n  O = function (n, t, e) {\n    var o = e.get,\n      i = c(t, n.field, o),\n      f = i[0],\n      a = i[1],\n      v = function (r) {\n        var t = o(r, a);\n        return Array.isArray(t) && t.length === n.value;\n      };\n    return n.field !== r && u(f, a) ? f.some(v) : v(f);\n  },\n  N = o(function (r, n) {\n    return \"string\" == typeof n && r.value.test(n);\n  }),\n  q = o(function (r, n, u) {\n    var e = u.compare;\n    return t(r.value, n, e);\n  }),\n  z = function (r, n, t) {\n    return !q(r, n, t);\n  },\n  E = function (r, n, u) {\n    var e = u.compare,\n      o = (0, u.get)(n, r.field);\n    return Array.isArray(o) && r.value.every(function (r) {\n      return t(o, r, e);\n    });\n  },\n  M = function (r, n, t) {\n    var u = t.interpret,\n      e = (0, t.get)(n, r.field);\n    return Array.isArray(e) && e.some(function (n) {\n      return u(r.value, n);\n    });\n  },\n  S = function (r, n) {\n    return r.value.call(n);\n  },\n  U = i({}, Object.freeze({\n    __proto__: null,\n    or: b,\n    nor: m,\n    and: d,\n    not: g,\n    eq: p,\n    ne: A,\n    lte: s,\n    lt: h,\n    gt: j,\n    gte: w,\n    exists: _,\n    mod: x,\n    size: O,\n    regex: N,\n    within: q,\n    nin: z,\n    all: E,\n    elemMatch: M,\n    where: S\n  }), {\n    in: q\n  }),\n  k = l(U);\nexport { E as all, U as allInterpreters, d as and, y as compare, v as createGetter, l as createJsInterpreter, M as elemMatch, p as eq, _ as exists, a as getObjectField, c as getObjectFieldCursor, j as gt, w as gte, k as interpret, h as lt, s as lte, x as mod, A as ne, z as nin, m as nor, g as not, b as or, N as regex, O as size, S as where, q as within };","map":{"version":3,"mappings":"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","names":["includes","items","value","compare","i","length","isArrayAndNotNumericField","object","field","Array","isArray","Number","isNaN","getField","get","result","concat","testValueOrArray","test","node","context","some","v","defaultGet","getObjectFieldCursor","path","dotIndex","lastIndexOf","slice","getObjectField","ITSELF","Error","String","indexOf","paths","split","getValueByPath","createGetter","a","b","createJsInterpreter","operators","options","createInterpreter","or","interpret","condition","nor","and","every","not","eq","ne","lte","lt","gt","gte","exists","item","hasOwnProperty","mod","size","regex","within","nin","all","elemMatch","where","call","allInterpreters","in","interpreters"],"sources":["../../src/utils.ts","../../src/interpreter.ts","../../src/interpreters.ts","../../src/defaults.ts"],"sourcesContent":["import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n","import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n","import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => !!value && value.hasOwnProperty(field) === node.value;\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n","import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n"]},"metadata":{},"sourceType":"module"}